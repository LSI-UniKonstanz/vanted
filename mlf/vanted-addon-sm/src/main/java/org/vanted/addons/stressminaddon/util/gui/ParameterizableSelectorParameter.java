package org.vanted.addons.stressminaddon.util.gui;

import de.ipk_gatersleben.ag_nw.graffiti.services.HandlesAlgorithmData;
import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;
import org.FolderPanel;
import org.GuiRow;
import org.graffiti.editor.MainFrame;
import org.graffiti.editor.dialog.ParameterEditPanel;
import org.graffiti.graph.Graph;
import org.graffiti.managers.EditComponentManager;
import org.graffiti.plugin.algorithm.Algorithm;
import org.graffiti.plugin.editcomponent.ValueEditComponent;
import org.graffiti.plugin.parameter.JComponentParameter;
import org.graffiti.plugin.parameter.Parameter;
import org.graffiti.plugin.parameter.SelectionParameter;
import org.graffiti.selection.Selection;

import javax.swing.*;
import java.awt.*;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
import java.util.*;

/**
 * The static methods in this class create special {@link JComponentParameter}s containing
 * a value similar to {@link org.graffiti.plugin.parameter.ObjectListParameter} that allows
 * to select a {@link Parameterizable} object from a list and displays these {@link Parameter}s
 * dynamically under it and updates them if a new Parameterizable is selected. If that is not possible
 * a button spawning a pop-up window with the Parameters is provided.
 *
 * @author Jannik
 */
public class ParameterizableSelectorParameter extends JPanel {

    /** A map containing the {@link Parameterizable}s to be used and the name to be display them as. */
    private Map<String, Parameterizable> displayNameParameterizableMap;
    /** A map containing the display name of the {@link Parameterizable}s to be used and a description of them. */
    private Map<String, String> displayNameDescriptionMap;
    /** The combo box containing the different choices. */
    private JComboBox<String> comboBox;
    /** The selection as the parameter was created. Is needed for {@link ValueEditComponent}. */
    private Selection selection;

    /** The currently selected {@link Parameterizable}. */
    private Parameterizable selectedParameterizable = null;
    /** The currently selected {@link Parameterizable}'s parameter. */
    private Parameter[] parametersOfParameterizable = null;
    /** The {@link ValueEditComponent}s generated by our {@link ParameterEditPanel}. */
    private LinkedList<ValueEditComponent> valueEditComponents = new LinkedList<>();
    /** The index of the currently selected item. Use to decide whether to update at all. */
    private int selectedIndex = -1;
    /**
     * The number of parameters currently placed under this, belonging to the currently
     * selected {@link Parameterizable}.
     */
    private int displayedParameters = 0;

    /** * The {@link FolderPanel} containing the {@link JComponentParameter} containing this object. */
    private FolderPanel parent = null;
    /**
     * The {@link ParameterEditPanel} containing the {@link FolderPanel} containing the {@link JComponentParameter}
     * containing this object.
     */
    private ParameterEditPanel editPanel = null;
    /** Whether the internal methods of our {@link ParameterEditPanel} could be accessed. */
    private boolean editPanelAccessible = false;
    /** Internal method of our {@link ParameterEditPanel}. */
    private Method editPanelAddStandardEditComponentRow = null;
    /** Internal method of our {@link ParameterEditPanel}. */
    private Method editPanelAddRow = null;
    /** Internal field of our {@link ParameterEditPanel}. */
    private Field editPanelEditTypeMap = null;
    /** Internal field of our {@link ParameterEditPanel}. */
    private Field editPanelDisplayedVEC = null;

    /** The button calling the falling pop up window. */
    private JButton fallback;

    /**
     * Creates a new parameter (which is a {@link JPanel}) that holds a {@link JComboBox} that allows the
     * user to select different {@link Parameterizable}s.
     *
     * @param initialSelection the element to select initially in the JComboBox.
     * @param displayNameParameterizableMap
     *      a map containing the {@link Parameterizable}s to be used and the
     *      name to be display them as.
     * @param displayNameDescriptionMap
     *      a map containing the display name of the {@link Parameterizable}s to be used
     *      and a description of them. These will be set as tooltip for the combo box.
     *      If a display name in {@code displayNameParameterizableMap} is
     *      not contained in this map no tooltip will be set.<br>
     *      This map may be {@code null}.
     * @param selection
     *      the current selection. This will be used for {@link SelectionParameter}s.
     *
     * @see ParameterizableSelectorParameter
     * @author Jannik
     */
    private ParameterizableSelectorParameter(final String initialSelection,
                                             final Map<String, Parameterizable> displayNameParameterizableMap,
                                             final Map<String, String> displayNameDescriptionMap,
                                             final Selection selection) {
        Objects.requireNonNull(this.displayNameParameterizableMap = displayNameParameterizableMap);
        Objects.requireNonNull(initialSelection);
        if (displayNameDescriptionMap != null) {
            this.displayNameDescriptionMap = displayNameDescriptionMap;
        } else {
            this.displayNameDescriptionMap = Collections.emptyMap();
        }
        this.selection = selection;

        String[] names;
        if (!displayNameParameterizableMap.isEmpty()) {
            names = displayNameParameterizableMap.keySet().toArray(new String[0]);
        } else {
            names = new String[]{"Nothing to select"};
        }


        this.setLayout(new BorderLayout());

        // set up initial selection
        this.comboBox = new JComboBox<>(names);
        if (!displayNameParameterizableMap.isEmpty()) {
            this.comboBox.setSelectedItem(initialSelection);
            this.selectedParameterizable = displayNameParameterizableMap.get(initialSelection);
            this.parametersOfParameterizable = selectedParameterizable.getParameters();
        }

        this.add(comboBox, BorderLayout.CENTER);
        comboBox.addActionListener(e -> updateEditPanel());
        // listen for changes in the hierarchy to get the components we are added to
        this.addHierarchyListener(e -> {
            if ( parent == null && e.getChangedParent() instanceof FolderPanel) {
                parent = (FolderPanel) e.getChangedParent();
            }
            if (editPanel == null && e.getChangedParent() instanceof ParameterEditPanel) {
                editPanel = (ParameterEditPanel) e.getChangedParent();
                editPanelAccessible = setUpEditPanel();
                updateEditPanel();
            }
        });

        // fallback button (gets disabled if updateEditPanel is called with valid fields)
        fallback = new JButton();
        if (displayNameParameterizableMap.isEmpty()) {
            comboBox.setEnabled(false);
            fallback.setVisible(false);
            fallback.setEnabled(false);
        } else {
            boolean somethingToSet =
                    this.parametersOfParameterizable != null &&
                    this.parametersOfParameterizable.length > 0;
            fallback.setVisible(somethingToSet);
            fallback.setEnabled(somethingToSet);

        }
        fallback.setText("Set parameters");
        this.add(fallback, BorderLayout.SOUTH);
        fallback.addActionListener(e -> {
            if (this.selectedParameterizable != null) {
                parameterPopUp();
            }});
        this.setVisible(true);
    }

    /**
     * @return
     *      the updated parameters of the current {@link Parameterizable}.
     *      This is only a convenience method: If the {@link Parameterizable}
     *      still owns its parameters they will be updated too.
     * @author Jannik
     */
    public Parameter[] getUpdatedParameters() {
        for (ValueEditComponent vec : valueEditComponents) {
            vec.setValue();
        }
        return this.parametersOfParameterizable;
    }

    /**
     * @return the currently selected {@link Parameterizable}.
     * @author Jannik
     */
    public Parameterizable getSelectedParameterizable() {
        return selectedParameterizable;
    }

    /**
     * Update the gui by placing the parameters of the currently selected {@link Parameterizable}
     * under this {@link ParameterizableSelectorParameter} in the active {@link ParameterEditPanel}.<br>
     * If this is not possible because something went wrong earlier use the fallback button instead.
     * @author Jannik
     */
    private void updateEditPanel() {
        if (selectedIndex == comboBox.getSelectedIndex() || displayNameDescriptionMap.isEmpty()) return;


        this.selectedParameterizable = this.displayNameParameterizableMap.get((String) comboBox.getSelectedItem());
        this.parametersOfParameterizable = this.selectedParameterizable.getParameters();
        this.comboBox.setToolTipText(this.displayNameDescriptionMap.getOrDefault(
                (String) comboBox.getSelectedItem(),null));
        selectedIndex = comboBox.getSelectedIndex();

        // if everything fails we have to use the fallback implementation
        if (editPanel == null || parent == null || !editPanelAccessible) {
            boolean somethingToSet =
                    this.parametersOfParameterizable != null &&
                    this.parametersOfParameterizable.length > 0;
            this.fallback.setVisible(somethingToSet);
            this.fallback.setEnabled(somethingToSet);
            return;
        } else {
            this.fallback.setVisible(false);
            this.fallback.setEnabled(false);
        }

        List<GuiRow> oldRows = new ArrayList<>(parent.getVisibleGuiRows());
        parent.clearGuiComponentList();
        int posThis = 0;
        // find the gui row containing this
        for (GuiRow row : oldRows) {
            parent.addGuiComponentRow(row, false);
            if (row.right == this) {
                break;
            } else {
                posThis++;
            }
        }

        // discard old set parameters
        if (oldRows.size() > posThis+displayedParameters+1) {
            oldRows = oldRows.subList(posThis+displayedParameters+1, oldRows.size());
        } else {
            oldRows = Collections.emptyList();
        }

        Parameter[] parameters = this.parametersOfParameterizable;
        this.displayedParameters = 0;
        this.valueEditComponents.clear();

        // from ParameterEditPanel
        try {
            if (parameters != null) {
                LinkedList editPanelDisplayedVEC = (LinkedList) this.editPanelDisplayedVEC.get(editPanel);
                Map editPanelEditTypeMap = (Map) this.editPanelEditTypeMap.get(editPanel);

                for (int i = 0; i < parameters.length; i++, displayedParameters++) {
                    if (parameters[i] instanceof SelectionParameter) {
                        // use currently active (given) selection instead
                        parameters[i] = new SelectionParameter(parameters[i].getName(), parameters[i].getDescription());
                        parameters[i].setValue(selection);
                    }

                    Class<?> ecClass = null;
                    if (parameters[i] != null && editPanelEditTypeMap != null)
                        ecClass = (Class<?>) editPanelEditTypeMap.get(parameters[i].getClass());

                    if (ecClass != null) {
                        // if we have a registered component to display it, add it
                        this.editPanelAddRow.invoke(editPanel, parent, parameters[i], ecClass);
                    } else {
                        // no component registered for this basic displayable
                        if (parameters[i] != null)
                            this.editPanelAddStandardEditComponentRow.invoke(editPanel, parent, parameters[i]);
                    }

                    this.valueEditComponents.add((ValueEditComponent) editPanelDisplayedVEC.removeLast());
                }
            }
        } catch (IllegalAccessException | InvocationTargetException e) {
            e.printStackTrace();
        }

        // add parameters after old parameters
        for (GuiRow old : oldRows) {
            parent.addGuiComponentRow(old, false);
        }

        parent.layoutRows();

    }

    /**
     * Set up the {@link ParameterEditPanel} to work with by trying to “expose” needed methods via reflection and
     * saving them in the corresponding fields for faster access.
     *
     * @return
     *      whether this action was successful.<br>
     *      The field {@link #editPanelAccessible} should be updated accordingly.
     * @author Jannik
     */
    private boolean setUpEditPanel() {
        try {
            this.editPanelAddStandardEditComponentRow = editPanel.getClass().getDeclaredMethod(
                    "addStandardTextEditComponentRow", FolderPanel.class, Parameter.class);
            this.editPanelAddStandardEditComponentRow.setAccessible(true);
            this.editPanelAddRow = editPanel.getClass().getDeclaredMethod("addRow", FolderPanel.class, Parameter.class, Class.class);
            this.editPanelAddRow.setAccessible(true);
            this.editPanelEditTypeMap = editPanel.getClass().getDeclaredField("editTypeMap");
            this.editPanelEditTypeMap.setAccessible(true);
            this.editPanelDisplayedVEC = editPanel.getClass().getDeclaredField("displayedVEC");
            this.editPanelDisplayedVEC.setAccessible(true);

        } catch (NoSuchMethodException | NoSuchFieldException | SecurityException e) {
            // This shouldn't happen in the current version of VANTED
            System.err.println(this.getClass().getCanonicalName() + ": Could not set up inner fields. Fallback to button.");
            return false;
        }
        return true;
    }

    /**
     * Show a JOptionPane-dialogue containing the {@link Parameter}s of the currently selected {@link Parameterizable}
     * and update the Parameters afterwards.<br>
     * Most of the code in this method comes from the method
     * {@link de.ipk_gatersleben.ag_nw.graffiti.plugins.gui.plugin_settings.PreferencesDialog#initAlgorithmPreferencesPanel(JDialog, Algorithm, Graph, Selection, HandlesAlgorithmData, boolean)}.
     * and is adapted from the MultiLevelFramework.<br>
     * This method must only be called if {@link #selectedParameterizable} is not {@code null}.
     *
     * @author Gordian, Jannik
     */
    private void parameterPopUp() {
        // adapted from PreferencesDialog.initAlgorithmPreferencesPanel
        JPanel progressAndStatus = new JPanel();
        double border = 5;
        double[][] size = {{border, TableLayoutConstants.FILL, border}, // Columns
                {border, TableLayoutConstants.PREFERRED, TableLayoutConstants.PREFERRED,
                        TableLayoutConstants.PREFERRED, border}}; // Rows

        progressAndStatus.setLayout(new TableLayout(size));


        final EditComponentManager editComponentManager = MainFrame.getInstance().getEditComponentManager();

        ParameterEditPanel paramPanel;

        if (this.parametersOfParameterizable != null) {
            paramPanel = new ParameterEditPanel(this.parametersOfParameterizable, editComponentManager.getEditComponents(), selection,
                     this.comboBox.getSelectedItem() + " parameters",
                    true, this.comboBox.getSelectedItem() + " parameters");
            JScrollPane sp = new JScrollPane(paramPanel);
            sp.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
            sp.setOpaque(false);
            sp.setBackground(null);
            progressAndStatus.add(sp, "1,2");
        } else {
            return;
        }

        progressAndStatus.validate();
        JOptionPane.showMessageDialog(MainFrame.getInstance(), new JScrollPane(paramPanel),
                "Set parameters of " + comboBox.getSelectedItem(), JOptionPane.PLAIN_MESSAGE);

        paramPanel.getUpdatedParameters();
    }

    /**
     * Creates a new parameter (which is a {@link JPanel}) that holds a {@link JComboBox} that allows the
     * user to select different {@link Parameterizable}s and packs it in the returned {@link JComponentParameter}.
     *
     * @param initialSelection
     *      the element to select initially in the JComboBox.
     *      If <code>displayNameParameterizableMap</code> is empty this will be ignored.
     * @param displayNameParameterizableMap
     *      a map containing the {@link Parameterizable}s to be used and the
     *      name to be display them as.
     * @param displayNameDescriptionMap
     *      a map containing the display name of the {@link Parameterizable}s to be used
     *      and a description of them. These will be set as tooltip for the combo box.
     *      If a display name in {@code displayNameParameterizableMap} is
     *      not contained in this map no tooltip will be set.<br>
     *      This map may be {@code null}.
     * @param selection
     *      the current selection. This will be used for {@link SelectionParameter}s.
     * @param name the name of the returned {@link JComponentParameter}.
     * @param description the description of the returned {@link JComponentParameter}.
     *
     * @see ParameterizableSelectorParameter
     * @author Jannik
     */
    public static JComponentParameter getFromMap(final String initialSelection,
                                                 final Map<String, Parameterizable> displayNameParameterizableMap,
                                                 final Map<String, String> displayNameDescriptionMap,
                                                 final Selection selection,
                                                 final String name, final String description) {
        Objects.requireNonNull(displayNameParameterizableMap);
        if (!displayNameParameterizableMap.isEmpty() && !displayNameParameterizableMap.containsKey(initialSelection)) {
            throw new IllegalArgumentException("'initialSelection' must be a key in 'displayNameParameterizableMap'!");
        }
        return new JComponentParameter(new ParameterizableSelectorParameter(
                initialSelection, displayNameParameterizableMap, displayNameDescriptionMap, selection), name, description);
    }

    /**
     * Creates a new parameter (which is a {@link JPanel}) that holds a {@link JComboBox} that allows the
     * user to select different {@link Parameterizable}s and packs it in the returned {@link JComponentParameter}.
     * The used descriptions will be automatically derived from the given {@link Parameterizable}s, if they are
     * instances of {@link Describable}.
     *
     * @param initialSelection
     *      the element to select initially in the JComboBox.
     *      If <code>displayNameParameterizableMap</code> is empty this will be ignored.
     * @param displayNameParameterizableMap
     *      a map containing the {@link Parameterizable}s to be used and the
     *      name to be display them as.
     * @param selection
     *      the current selection. This will be used for {@link SelectionParameter}s.
     * @param name the name of the returned {@link JComponentParameter}.
     * @param description the description of the returned {@link JComponentParameter}.
     *
     * @see ParameterizableSelectorParameter
     * @author Jannik
     */
    public static JComponentParameter getFromMap(final String initialSelection,
                                                 final Map<String, Parameterizable> displayNameParameterizableMap,
                                                 final Selection selection,
                                                 final String name, final String description) {
        Objects.requireNonNull(displayNameParameterizableMap);
        if (!displayNameParameterizableMap.isEmpty() && !displayNameParameterizableMap.containsKey(initialSelection)) {
            throw new IllegalArgumentException("'initialSelection' must be a key in 'displayNameParameterizableMap'!");
        }
        Map<String, String> descriptions = new HashMap<>();
        for (Map.Entry<String, Parameterizable> entry : displayNameParameterizableMap.entrySet()) {
            if (entry.getValue() instanceof Describable) {
                descriptions.put(entry.getKey(), ((Describable) entry.getValue()).getDescription());
            }
        }
        return new JComponentParameter(new ParameterizableSelectorParameter(
                initialSelection, displayNameParameterizableMap, descriptions, selection), name, description);
    }

    /**
     * Creates a new parameter (which is a {@link JPanel}) that holds a {@link JComboBox} that allows the
     * user to select different {@link Parameterizable}s and packs it in the returned {@link JComponentParameter}.
     * The used names descriptions will be automatically derived from the given {@link Parameterizable}s.
     *
     * @param initialSelection
     *      the index of the element to select initially in the JComboBox.
     *      If <code>describableParameterizableList</code> is empty this will be ignored.
     * @param describableParameterizableList
     *      a list containing the objects to be selectable. Their name and description will be used
     *      to fill the JComboBox.<br>
     *      The names of these objects may not be <code>null</code>.
     * @param selection
     *      the current selection. This will be used for {@link SelectionParameter}s.
     * @param name the name of the returned {@link JComponentParameter}.
     * @param description the description of the returned {@link JComponentParameter}.
     *
     * @see ParameterizableSelectorParameter
     * @author Jannik
     */
    public static <T extends Parameterizable & Describable> JComponentParameter
                                      getFromList(final int initialSelection,
                                                  final List<T> describableParameterizableList,
                                                  final Selection selection,
                                                  final String name, final String description) {
        Objects.requireNonNull(describableParameterizableList);
        if (!describableParameterizableList.isEmpty() && ( 0 > initialSelection || initialSelection >= describableParameterizableList.size() )) {
            throw new IndexOutOfBoundsException("'initialSelection' must point in 'describableParameterizableList'!");
        }
        Map<String, Parameterizable> parameterizable = new LinkedHashMap<>();
        Map<String, String> descriptions = new HashMap<>();
        for (T item : describableParameterizableList) {
            if (item.getName() == null) {
                throw new IllegalArgumentException("The names of the provided 'Describable's may not be null!: " + item);
            }
            parameterizable.put(item.getName(), item);
            descriptions.put(item.getName(), item.getDescription());
        }
        return new JComponentParameter(new ParameterizableSelectorParameter(
                describableParameterizableList.isEmpty() ? "" : describableParameterizableList.get(initialSelection).getName(),
                parameterizable, descriptions, selection), name, description);
    }
}
